<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Todo List Online - Minimalist, Cloud Web Todo App</title>
    <meta
      name="keywords"
      content="online todo list, minimalist todo app, cloud saved todo, web todo list, todo manager, task scheduler, memo app, browser-based todo, instant access, secure storage, personal todo, professional todo, work and life assistant"
    />
    <meta
      name="description"
      content="uiineed's Todo List Online is a minimalist, web app that helps you manage your tasks and schedules effortlessly. Store your todos securely in the cloud, and enjoy a seamless experience without the hassle of missing the list. Perfect for both personal and professional use!"
    />
    <link type="favicon" rel="shortcut icon" href="public/img/favicon.png" />
    <link href="public/css/normalize.css" rel="stylesheet" media="screen" />
    <link href="public/css/style.min.css" rel="stylesheet" media="screen" />
    <script>
      localStorage.setItem("uiineed-todos-lang", "en");
      const userLanguage = localStorage.getItem("uiineed-todos-lang");
    </script>

    <script>
      const nativeAlert = window.alert;
      window.alert = function (message, title = "Prompt") {
        return new Promise((resolve) => {
          const overlay = document.createElement("div");
          overlay.className = "custom-alert-overlay";
          const alertBox = document.createElement("div");
          alertBox.className = "custom-alert";
          alertBox.innerHTML = `
<div class="custom-alert-title">${title}</div>
<div class="custom-alert-content">${message}</div>
<div class="custom-alert-buttons">
        <button class="custom-alert-btn confirm">OK</button>
</div>
      `;
          overlay.appendChild(alertBox);
          document.body.appendChild(overlay);
          const confirmBtn = alertBox.querySelector(".confirm");
          confirmBtn.addEventListener("click", () => {
            alertBox.style.animation = "popOut 0.3s forwards";
            setTimeout(() => {
              document.body.removeChild(overlay);
              resolve(true);
            }, 300);
          });
          overlay.addEventListener("keydown", (e) => {
            if (e.key === "Escape") confirmBtn.click();
          });
          confirmBtn.focus();
        });
      };

      const nativeConfirm = window.alert;
      window.confirm = function (message, title = "Please Confirm") {
        return new Promise((resolve) => {
          const overlay = document.createElement("div");
          overlay.className = "custom-alert-overlay";
          const alertBox = document.createElement("div");
          alertBox.className = "custom-alert";
          alertBox.innerHTML = `
<div class="custom-alert-title">${title}</div>
<div class="custom-alert-content">${message}</div>
<div class="custom-alert-buttons">
        <button class="custom-alert-btn cancel">Cancel</button>
        <button class="custom-alert-btn confirm">OK</button>
</div>
      `;
          overlay.appendChild(alertBox);
          document.body.appendChild(overlay);
          const confirmBtn = alertBox.querySelector(".confirm");
          const cancelBtn = alertBox.querySelector(".cancel");
          confirmBtn.addEventListener("click", () => {
            alertBox.style.animation = "popOut 0.3s forwards";
            setTimeout(() => {
              document.body.removeChild(overlay);
              resolve(true);
            }, 300);
          });
          cancelBtn.addEventListener("click", () => {
            alertBox.style.animation = "popOut 0.3s forwards";
            setTimeout(() => {
              document.body.removeChild(overlay);
              resolve(false);
            }, 300);
          });
          overlay.addEventListener("keydown", (e) => {
            if (e.key === "Escape") cancelBtn.click();
          });
          cancelBtn.focus();
        });
      };
    </script>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script src="public/js/vue.js"></script>
    <script src="public/js/config.js"></script>
    <script src="public/js/apiService.js"></script>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        const token = localStorage.getItem("jwt_token");
        if (!token) {
          window.location.href = "login.html";
        }
      });
    </script>
  </head>

  <body>
    <div class="bg-pattern"></div>
    <div class="todo-wrapper">
      <div id="todo-app" class="todo-app">
        <div class="container header">
          <div class="todo-input">
            <h1 class="title">
              <img
                src="public/img/todo.svg"
                alt=""
                class="title-1"
                draggable="false"
              />
              <div class="ani-vector">
                <span></span>
                <span></span>
              </div>
              <div class="pendulums">
                <div class="pendulum">
                  <div class="bar"></div>
                  <div class="motion">
                    <div class="string"></div>
                    <div class="weight"></div>
                  </div>
                </div>
                <div class="pendulum shadow">
                  <div class="bar"></div>
                  <div class="motion">
                    <div class="string"></div>
                    <div class="weight"></div>
                  </div>
                </div>
              </div>
            </h1>
            <div class="add-content-wrapper">
              <input
                type="text"
                rows="3"
                class="add-content"
                placeholder="Add a to-do item..."
                v-model="newTodoTitle"
                @keyup.enter="addTodo"
                :class="{empty:emptyChecked}"
              />
              <transition name="tips">
                <div class="tips" v-if="emptyChecked" style="color: red">
                  üí°Please enter content!
                </div>
              </transition>
              <button class="btn submit-btn" type="button" @click="addTodo">
                Add
              </button>
            </div>
          </div>
        </div>

        <div class="container main">
          <div class="todo-list-box">
            <div class="bar-message">
              <input
                type="button"
                class="btn btn-label btn-allFinish"
                value="Mark All Done"
                @click="markAllAsCompleted"
                v-if="todos.length || recycleBin.length"
              />
              <template>
                <div>
                  <div
                    v-if="!isEditing"
                    @dblclick="editText"
                    class="bar-message-text"
                  >
                    {{ slogan }}
                  </div>
                  <div v-else="v-else">
                    <input
                      v-model="slogan"
                      ref="sloganInput"
                      class="slogan-input"
                      @keyup.enter="saveText"
                      @keyup.esc="cancelText"
                    />
                    <div
                      class="todo-btn btn-edit-submit slogan-btn"
                      @click="saveText"
                    >
                      <img src="public/img/delete.svg" alt="Finish" />
                    </div>
                  </div>
                </div>
              </template>
            </div>

            <ul v-if="!todos.length && showEmptyTips" class="empty-tips">
              <li>Add Your First To-Do Item! üìù</li>
              <li>Usage Tips üí°:</li>
              <li>‚úîÔ∏è Press Enter to submit actions.</li>
              <li>‚úîÔ∏è Drag to reorder your to-dos (PC only)</li>
              <li>‚úîÔ∏è Double-click to edit slogan and tasks.</li>
              <li>‚úîÔ∏è Access quick actions in the right sidebar.</li>
              <li>üîí Your data is stored in the cloud.</li>
              <li>üìù Supports data download and import.</li>
            </ul>

            <transition-group
              name="drag"
              class="todo-list"
              tag="ul"
              mode="in-out"
              @before-enter="beforeEnter"
              @enter="enter"
              @after-enter="afterEnter"
              :css="false"
              appear="appear"
            >
              <li
                v-for="(todo, index) in filteredTodos"
                :key="todo.id"
                class="todo-item"
                @dragenter="dragenter($event, index)"
                @dragover="dragover($event, index)"
                @dragstart="dragstart(index)"
                @dragend="dragend($event)"
                :data-delay="index * 150 * delayTime"
                v-show="show"
                :draggable="!(editedTodo !== null && editedTodo.id === todo.id)"
              >
                <div
                  class="todo-content"
                  :class="{completed:todo.completed}"
                  @dblclick="editdTodo(todo)"
                >
                  {{ todo.title }}
                </div>
                <div
                  class="todo-btn btn-finish"
                  v-if="!todo.completed"
                  @click="markAsCompleted(todo)"
                ></div>
                <div
                  class="todo-btn btn-unfinish"
                  v-if="todo.completed"
                  @click="markAsUncompleted(todo)"
                >
                  <img
                    src="public/img/complete.svg"
                    alt="Mark as Incomplete"
                    class="icon-finish"
                    draggable="false"
                  />
                </div>
                <div
                  v-if="todo.removed"
                  class="todo-btn btn-restore"
                  @click="restoreTodo(todo)"
                >
                  <img
                    src="public/img/restore.svg"
                    alt="Restore"
                    draggable="false"
                  />
                </div>
                <div
                  class="todo-btn btn-delete"
                  v-else="todo.removed"
                  @click="removeTodo(todo)"
                >
                  <img
                    src="public/img/delete.svg"
                    alt="Delete"
                    draggable="false"
                  />
                </div>

                <div
                  class="edit-todo-wrapper"
                  v-if="editedTodo !== null && editedTodo.id === todo.id"
                >
                  <input
                    type="text"
                    class="edit-todo"
                    value="Edit Todo..."
                    v-if="editedTodo !== null && editedTodo.id === todo.id"
                    v-model="todo.title"
                    v-focus="true"
                    @keyup.enter="editDone(todo)"
                    @keyup.esc="cancelEdit(todo)"
                    @dragstart.stop.prevent
                    @mousedown.stop
                  />
                  <div class="todo-btn btn-edit-submit" @click="editDone(todo)">
                    <img
                      src="public/img/submit.svg"
                      alt="Submit"
                      draggable="false"
                    />
                  </div>
                </div>
              </li>
            </transition-group>

            <div class="bar-message bar-bottom">
              <div class="bar-message-text">
                <span v-if="leftTodosCount"
                  >{{ leftTodosCount }} items remaining</span
                >
                <span v-else-if="completedTodosCount"
                  >All completed, good job!</span
                >
              </div>
            </div>
          </div>

          <div class="footer side-bar">
            <div
              class="side-shortcut"
              @click="shortCutAction()"
              :class="{fold: isShow}"
            >
              <div class="shortcut-switch">
                <span class="shortcut-title">{{ shortCut }}</span>
                <span class="shortcut-name">Quicks</span>
              </div>
            </div>

            <div class="todo-footer-box">
              <ul class="todo-func-list filter">
                <li>
                  <input
                    class="btn-small action-showAll"
                    type="button"
                    value="All"
                    :class="{selected: intention === 'all'}"
                    @click="intention ='all'"
                  />
                </li>
                <li v-if="completedTodosCount">
                  <input
                    class="btn-small action-progress"
                    type="button"
                    value="In Progress"
                    v-if="leftTodosCount"
                    :class="{selected: intention === 'ongoing'}"
                    @click="intention ='ongoing'"
                  />
                </li>
                <li v-if="completedTodosCount">
                  <input
                    class="btn-small action-completed"
                    type="button"
                    value="Completed"
                    v-if="completedTodosCount"
                    :class="{selected: intention === 'completed'}"
                    @click="intention='completed'"
                  />
                </li>
                <li v-if="recycleBin.length">
                  <input
                    class="btn-small action-deleted"
                    type="button"
                    v-if="recycleBin.length"
                    :class="{selected: intention === 'removed'}"
                    value="Trash"
                    @click="intention='removed'"
                  />
                </li>
              </ul>

              <ul class="todo-func-list batch">
                <li v-if="leftTodosCount">
                  <input
                    type="button"
                    class="btn-small completed-all"
                    v-if="leftTodosCount"
                    value="Finish all"
                    @click="markAllAsCompleted"
                  />
                </li>
                <li v-if="completedTodosCount">
                  <input
                    type="button"
                    value="Clear Completed"
                    class="btn-small completed-clear"
                    v-if="completedTodosCount"
                    @click="clearCompleted"
                  />
                </li>
                <li v-if="todos.length">
                  <input
                    type="button"
                    class="btn-small clear-all"
                    value="Clear All"
                    @click="clearAll"
                  />
                </li>
              </ul>

              <ul class="todo-func-list datasave">
                <li v-if="leftTodosCount">
                  <input
                    type="button"
                    value="Export data"
                    class="btn-small action-download"
                    id="download"
                    onclick="handleClickDownload()"
                  />
                </li>
                <li>
                  <input
                    value="Import(txt/json)"
                    type="button"
                    class="btn-small action-import"
                    id="import"
                  />
                </li>
              </ul>

              <ul class="todo-func-list batch">
                <li>
                  <input
                    type="button"
                    value="Sequence Task"
                    class="btn-small action-import"
                    id="sequence-task-btn"
                  />
                </li>
              </ul>
            </div>
          </div>
        </div>

        <div class="nav">
          <span>{{ userEmail }}</span>
          <div class="github">
            <a
              href="https://github.com/ainh01/todo"
              target="_blank"
              class="social-link"
              draggable="false"
            >
              <img
                src="public/img/social/github.svg"
                class="ic-social"
                alt=""
                draggable="false"
              />
            </a>
          </div>
          <div class="about">
            <div class="info">
              <div
                class="info-ico"
                @click="togglePop"
                :style="{ fontWeight: popShow ? 'normal' : 'bold' }"
              >
                About
              </div>
              <div class="popup animated popIn" v-if="!popShow">
                <div class="author">
                  <img src="public/img/author.png" alt="" />
                  Ainh01
                </div>
                <div class="author-info">
                  <div class="author-desc">Hate cod-</div>
                </div>
                <div class="social">
                  <a
                    href="https://github.com/ainh01/todo"
                    target="_blank"
                    class="social-link"
                    draggable="false"
                  >
                    <img
                      src="public/img/social/github.svg"
                      class="ic-social"
                      alt=""
                      draggable="false"
                    />
                  </a>
                  <a href="mailto:binhtx204@gmail.com" class="social-link">
                    <img
                      src="public/img/social/mail.svg"
                      class="ic-social"
                      alt=""
                    />
                  </a>
                </div>
                <a
                  href="https://www.facebook.com/Binh.MM.mm"
                  target="_blank"
                  class="inspiration"
                  >üîñFacebook‚Üó
                </a>
              </div>
            </div>
          </div>

          <div class="user-info">
            <button
              class="shortcut-title"
              style="background-color: rgb(250, 233, 254); border-radius: 3px"
              @click="logout"
            >
              Logout
            </button>
          </div>
        </div>
      </div>
    </div>

    <script>
      var todoStorage = {
        async fetch() {
          try {
            const response = await ApiService.getTasks();
            const todos = response.data || response;

            const normalizedTodos = (Array.isArray(todos) ? todos : []).map(
              (todo) => ({
                id: todo.task_id,
                title: todo.title || "",
                slot: todo.slot || 0,
                completed: todo.finished || false,
                removed: false,
                created_at: todo.created_at,
                updated_at: todo.updated_at,
              }),
            );

            return normalizedTodos.sort((a, b) => a.slot - b.slot);
          } catch (error) {
            console.error("Failed to fetch todos:", error);
            return [];
          }
        },
      };
    </script>

    <script>
      const sound = new Audio("/public/sound/confetti.mp3");
      var app = new Vue({
        el: "#todo-app",

        data: function () {
          return {
            todos: [],
            newTodoTitle: "",
            editedTodo: null,
            intention: "all",
            checkEmpty: false,
            recycleBin: [],
            dragIndex: null,
            originalIndex: null,
            draggedItem: null,
            enterIndex: "",
            show: true,
            delayTime: "1",
            isShow: false,
            shortCut: "OPEN‚ú®",
            popShow: true,
            windowWidth: document.documentElement.clientWidth,
            slogan: this.getSlogan(),
            isEditing: false,
            originalSlogan: "",
            userEmail: localStorage.getItem("user_email") || "",
            isLoading: false,
            confettiColors: [
              "#a864fd",
              "#29cdff",
              "#78ff44",
              "#ff718d",
              "#fdff6a",
            ],
          };
        },

        async created() {
          await this.loadTodos();
        },

        watch: {
          windowWidth(val) {},
        },

        methods: {
          async loadTodos() {
            this.isLoading = true;
            try {
              const fetchedTodos = await todoStorage.fetch();
              this.todos = fetchedTodos;
            } catch (error) {
              await alert("Failed to load todos: " + error.message, "Error");
            } finally {
              this.isLoading = false;
            }
          },

          editText() {
            this.originalSlogan = this.slogan;
            this.isEditing = true;
            this.$nextTick(() => {
              this.$refs.sloganInput.focus();
            });
          },

          saveText() {
            this.isEditing = false;
            localStorage.setItem("uiineed-slogan", this.slogan);
          },

          cancelText() {
            this.slogan = this.originalSlogan;
            this.isEditing = false;
          },

          getSlogan() {
            return (
              localStorage.getItem("uiineed-slogan") ||
              "Act Now, Simplify Life.‚òï"
            );
          },

          contorlScreen: function () {
            if (this.windowWidth < 768) {
              this.isShow = !this.isShow;
              return (this.shortCut = "Filter");
            }
          },

          togglePop: function () {
            this.popShow = !this.popShow;
          },

          shortCutAction: function () {
            this.isShow = !this.isShow;
            if (this.isShow) {
              return (this.shortCut = "Ôºù");
            } else {
              return (this.shortCut = "OPEN‚ú®");
            }
          },

          async addTodo(e) {
            if (this.newTodoTitle === "") {
              this.checkEmpty = true;
              return;
            }

            try {
              const response = await ApiService.createTask(this.newTodoTitle);
              const newTodo = response.data || response;

              this.todos.unshift({
                id: newTodo.task_id,
                title: newTodo.title,
                slot: newTodo.slot,
                completed: newTodo.finished || false,
                removed: false,
              });

              this.newTodoTitle = "";
              this.checkEmpty = false;
              this.delayTime = "0";
              await this.loadTodos();
            } catch (error) {
              await alert("Failed to add todo: " + error.message, "Error");
            }
          },

          async markAsCompleted(todo) {
            try {
              sound.currentTime = 0;
              const response = await ApiService.finishTask(todo.id, true);
              const updated = response.data || response;
              todo.completed = updated.finished;
              const remainingIncompleteTasks = this.todos.filter(
                (t) => !t.completed && !t.removed && t.id !== todo.id,
              ).length;

              await this.loadTodos();

              this.celebrateCompletion();
            } catch (error) {
              await alert(
                "Failed to mark as completed: " + error.message,
                "Error",
              );
            }
          },

          async markAsUncompleted(todo) {
            try {
              const response = await ApiService.finishTask(todo.id, false);
              const updated = response.data || response;
              todo.completed = updated.finished;
              await this.loadTodos();
            } catch (error) {
              await alert(
                "Failed to mark as uncompleted: " + error.message,
                "Error",
              );
            }
          },

          celebrateCompletion() {
            sound.play();
            if (typeof confetti !== "undefined") {
              confetti({
                particleCount: 350,
                startVelocity: 88,
                drift: 0.3,
                angle: 45,
                spread: 70,
                origin: { x: 0.0, y: 1.0 },
                colors: this.confettiColors,
              });
              confetti({
                particleCount: 350,
                startVelocity: 88,
                drift: 0.3,
                angle: 135,
                spread: 70,
                origin: { x: 1.0, y: 1.0 },
                colors: this.confettiColors,
              });
            } else {
              console.warn("Confetti library not loaded.");
            }
          },

          async markAllAsCompleted() {
            sound.currentTime = 0;
            const confirmed = await confirm(
              "Confirm to mark all as completed?",
            );
            if (confirmed) {
              try {
                const incompleteTodos = this.todos.filter(
                  (todo) => !todo.completed && !todo.removed,
                );
                if (incompleteTodos.length === 0) {
                  await alert(
                    "No incomplete tasks to mark as completed.",
                    "Info",
                  );
                  return;
                }

                const updatePromises = incompleteTodos.map(async (todo) => {
                  await ApiService.finishTask(todo.id, true);
                });

                await Promise.all(updatePromises);
                this.celebrateCompletion();
                await this.loadTodos();
              } catch (error) {
                await alert(
                  "Some items failed to update: " + error.message,
                  "Error",
                );
              }
            }
          },

          async removeTodo(todo) {
            try {
              await ApiService.deleteTask(todo.id);
              let removedTodo = this.todos.splice(
                this.todos.indexOf(todo),
                1,
              )[0];
              removedTodo.removed = true;
              this.recycleBin.unshift(removedTodo);
            } catch (error) {
              await alert("Failed to delete todo: " + error.message, "Error");
              await this.loadTodos();
            }
          },

          async restoreTodo(todo) {
            try {
              const response = await ApiService.createTask(todo.title);
              const restoredTodoData = response.data || response;

              const newTodo = {
                id: restoredTodoData.task_id,
                title: restoredTodoData.title,
                slot: restoredTodoData.slot,
                completed: restoredTodoData.finished || false,
                removed: false,
              };

              this.todos.unshift(newTodo);

              let pos = this.recycleBin.indexOf(todo);
              if (pos > -1) {
                this.recycleBin.splice(pos, 1);
              }
              await this.loadTodos();
            } catch (error) {
              await alert("Failed to restore todo: " + error.message, "Error");
              await this.loadTodos();
            }
          },

          editdTodo: function (todo) {
            this.editedTodo = {
              id: todo.id,
              title: todo.title,
              originalTitle: todo.title,
            };
          },

          async editDone(todo) {
            if (todo.title === "") {
              const confirmed = await confirm(
                "Task title is empty. Delete this task?",
                "Confirm Deletion",
              );
              if (confirmed) {
                await this.removeTodo(todo);
              } else {
                todo.title = this.editedTodo.originalTitle;
              }
              this.editedTodo = null;
              return;
            }

            try {
              await ApiService.updateTask(todo.id, todo.title);
              this.editedTodo = null;
              await this.loadTodos();
            } catch (error) {
              await alert("Failed to update todo: " + error.message, "Error");
              if (this.editedTodo && this.editedTodo.id === todo.id) {
                todo.title = this.editedTodo.originalTitle;
              }
              this.editedTodo = null;
              await this.loadTodos();
            }
          },

          cancelEdit: function (todo) {
            if (this.editedTodo && this.editedTodo.id === todo.id) {
              todo.title = this.editedTodo.originalTitle;
            }
            this.editedTodo = null;
          },

          async clearCompleted() {
            const confirmed = await confirm(
              "Confirm to clear all completed items?",
            );
            if (confirmed) {
              try {
                const completedTodos = this.todos.filter(
                  (todo) => todo.completed && !todo.removed,
                );
                if (completedTodos.length === 0) {
                  await alert("No completed tasks to clear.", "Info");
                  return;
                }

                const deletePromises = completedTodos.map((todo) =>
                  ApiService.deleteTask(todo.id),
                );

                await Promise.all(deletePromises);
                await this.loadTodos();
                this.recycleBin = this.recycleBin.concat(
                  completedTodos.map((todo) => ({ ...todo, removed: true })),
                );
              } catch (error) {
                await alert(
                  "Failed to clear completed items: " + error.message,
                  "Error",
                );
              }
            }
          },

          async clearAll() {
            const confirmed = await confirm("Confirm to clear all todo items?");
            if (confirmed) {
              try {
                if (this.todos.length === 0 && this.recycleBin.length === 0) {
                  await alert("No tasks to clear.", "Info");
                  return;
                }

                const allTaskIds = [
                  ...this.todos.map((t) => t.id),
                  ...this.recycleBin.map((t) => t.id),
                ];
                const deletePromises = allTaskIds.map((id) =>
                  ApiService.deleteTask(id),
                );

                await Promise.all(deletePromises);

                this.recycleBin = this.recycleBin.concat(
                  this.todos.map((todo) => ({ ...todo, removed: true })),
                );
                this.todos = [];
                await this.loadTodos();
              } catch (error) {
                await alert(
                  "Failed to clear all items: " + error.message,
                  "Error",
                );
              }
            }
          },

          dragstart: function (index) {
            this.dragIndex = index;
            this.originalIndex = index;
            this.draggedItem = this.filteredTodos[index];
            event.dataTransfer.setData(
              "text/plain",
              JSON.stringify(this.draggedItem),
            );
            event.dataTransfer.effectAllowed = "move";
          },

          dragenter(e, index) {
            e.preventDefault();
            if (this.dragIndex !== index && this.draggedItem) {
              if (
                this.intention === "ongoing" ||
                this.intention === "completed" ||
                this.intention === "all"
              ) {
                const movedItem = this.filteredTodos.splice(
                  this.dragIndex,
                  1,
                )[0];
                this.filteredTodos.splice(index, 0, movedItem);
                this.dragIndex = index;
              }
            }
          },

          dragover: function (e, index) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
          },

          async dragend(e) {
            e.preventDefault();

            if (this.draggedItem && this.originalIndex !== this.dragIndex) {
              const targetSlot = this.dragIndex + 1;

              try {
                await ApiService.moveTask(this.draggedItem.id, targetSlot);

                await this.loadTodos();
              } catch (error) {
                console.error("Failed to move task:", error);
                await alert("Failed to move task: " + error.message, "Error");

                await this.loadTodos();
              }
            }

            this.draggedItem = null;
            this.originalIndex = null;
            this.dragIndex = null;
          },

          beforeEnter(dom) {
            dom.classList.add("drag-enter-active");
          },

          enter(dom, done) {
            let delay = dom.dataset.delay;
            setTimeout(() => {
              this.delayTime = "1";
              dom.classList.remove("drag-enter-active");
              dom.classList.add("drag-enter-to");
              let transitionend = window.ontransitionend
                ? "transitionend"
                : "webkitTransitionEnd";
              dom.addEventListener(transitionend, function onEnd() {
                dom.removeEventListener(transitionend, onEnd);
                done();
              });
            }, delay);
          },

          afterEnter(dom) {
            dom.classList.remove("drag-enter-to");
          },

          saveLanguage(lang) {
            localStorage.setItem("uiineed-todos-lang", lang);
          },

          logout() {
            localStorage.removeItem("jwt_token");
            localStorage.removeItem("user_email");
            window.location.href = "login.html";
          },
        },

        mounted() {
          this.show = true;
          var that = this;
          this.contorlScreen();

          window.onresize = () => {
            return (() => {
              window.fullWidth = document.documentElement.clientWidth;
              that.windowWidth = window.fullWidth;
            })();
          };
        },

        directives: {
          focus: {
            inserted: function (el) {
              el.focus();
            },
          },
        },

        computed: {
          emptyChecked: function () {
            return this.newTodoTitle.length === 0 && this.checkEmpty;
          },

          leftTodos: function () {
            return this.todos.filter(function (todo) {
              return !todo.completed && !todo.removed;
            });
          },

          leftTodosCount: function () {
            return this.leftTodos.length;
          },

          hasRemovedTodo: function () {
            return this.recycleBin.length > 0;
          },

          completedTodos: function () {
            return this.todos.filter(function (todo) {
              return todo.completed && !todo.removed;
            });
          },

          completedTodosCount: function () {
            return this.completedTodos.length;
          },

          filteredTodos: {
            get: function () {
              if (this.intention === "ongoing") {
                return this.leftTodos;
              } else if (this.intention === "completed") {
                return this.completedTodos;
              } else if (this.intention === "removed") {
                return this.recycleBin;
              } else {
                return this.todos.filter((todo) => !todo.removed);
              }
            },
            set: function (newValue) {
              if (this.intention === "all") {
                this.todos = newValue;
              } else if (this.intention === "ongoing") {
              } else if (this.intention === "completed") {
              } else if (this.intention === "removed") {
                this.recycleBin = newValue;
              }
            },
          },

          showEmptyTips() {
            return (
              this.filteredTodos.length === 0 && this.intention !== "removed"
            );
          },
        },
      });
    </script>

    <script>
      const handleClickDownload = async () => {
        try {
          const todosData = app.todos
            .filter((todo) => !todo.removed)
            .map((todo) => ({
              title: todo.title,
              completed: todo.completed,
            }));

          const todosText = JSON.stringify(todosData, null, 2);
          const date = new Date().toISOString().replace(/-|:|\.\d+/g, "");
          const fileName = `todos-${date.slice(0, 8)}-${date.slice(9, 15)}.json`;

          const element = document.createElement("a");
          element.href =
            "data:application/json;charset=utf-8," +
            encodeURIComponent(todosText);
          element.download = fileName;

          document.body.appendChild(element);
          element.click();
          document.body.removeChild(element);
        } catch (error) {
          await alert("Export failed: " + error.message, "Error");
        }
      };

      let tempFileInput = null;

      document.addEventListener("DOMContentLoaded", function () {
        const importBtn = document.getElementById("import");

        if (importBtn) {
          importBtn.addEventListener("click", function () {
            if (!tempFileInput) {
              tempFileInput = document.createElement("input");
              tempFileInput.type = "file";
              tempFileInput.accept = ".txt,.json";
              tempFileInput.style.display = "none";
              this.parentNode.appendChild(tempFileInput);

              tempFileInput.addEventListener("change", async function (event) {
                var file = event.target.files[0];
                if (!file) {
                  await alert("No file selected!", "Error");
                  return;
                }

                var reader = new FileReader();
                reader.onload = async function (e) {
                  var content = e.target.result;
                  try {
                    var importedData = JSON.parse(content.trim());

                    if (!Array.isArray(importedData)) {
                      throw new Error(
                        "Invalid format: expected array of todos",
                      );
                    }

                    let successCount = 0;
                    let failureCount = 0;
                    for (let item of importedData) {
                      try {
                        const titleToImport = item.title
                          ? String(item.title)
                          : "Imported Task";
                        await ApiService.createTask(
                          titleToImport,
                          item.description || "",
                          item.completed || false,
                        );
                        successCount++;
                      } catch (err) {
                        console.error("Failed to import item:", item, err);
                        failureCount++;
                      }
                    }

                    await app.loadTodos();
                    if (failureCount === 0) {
                      await alert(
                        `Successfully imported ${successCount} of ${importedData.length} items!`,
                        "Import Success",
                      );
                    } else {
                      await alert(
                        `Import completed with ${successCount} successes and ${failureCount} failures. See console for details.`,
                        "Import Partial Success",
                      );
                    }
                  } catch (error) {
                    await alert(
                      "File parsing error: " +
                        error.message +
                        ". Please ensure the file is a valid JSON array of todo objects.",
                      "Error",
                    );
                  }
                };

                reader.onerror = async function (e) {
                  await alert(
                    "Error reading file: " + e.target.error.name,
                    "Error",
                  );
                };

                reader.readAsText(file);
                if (this.parentNode && tempFileInput) {
                  this.parentNode.removeChild(tempFileInput);
                  tempFileInput = null;
                }
              });
            }
            tempFileInput.click();
          });
        }
      });
    </script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const seqBtn = document.getElementById("sequence-task-btn");
        if (!seqBtn) return;

        seqBtn.addEventListener("click", openSequenceDialog);
      });

      function openSequenceDialog() {
        const overlay = document.createElement("div");
        overlay.className = "custom-alert-overlay";

        const box = document.createElement("div");
        box.className = "custom-alert";

        box.innerHTML = `
      <div class="custom-alert-title" style="text-align:center">Sequence Task</div>
      <div class="custom-alert-content" style="text-align:left">

        <div style="margin-bottom:10px">
          <label style="margin-right:16px; cursor:pointer">
            <input type="radio" name="seq-position" value="prefix" id="seq-prefix" />
            Prefix &nbsp;<span style="opacity:.6;font-size:.85em">(x+Task)</span>
          </label>
          <label style="cursor:pointer">
            <input type="radio" name="seq-position" value="suffix" id="seq-suffix" checked />
            Suffix &nbsp;<span style="opacity:.6;font-size:.85em">(Task+x)</span>
          </label>
        </div>

        <div style="margin-bottom:8px">
          <label style="display:block;margin-bottom:4px;font-weight:600">Task Name</label>
          <input
            id="seq-task-name"
            type="text"
            placeholder="e.g. Finish part 3."
            style="width:100%;box-sizing:border-box;padding:6px 8px;border:1px solid #ccc;border-radius:4px;font-size:14px"
          />
        </div>

        <div style="display:flex;gap:12px;margin-bottom:8px">
          <div style="flex:1">
            <label style="display:block;margin-bottom:4px;font-weight:600">From</label>
            <input
              id="seq-from"
              type="number"
              value="1"
              style="width:100%;box-sizing:border-box;padding:6px 8px;border:1px solid #ccc;border-radius:4px;font-size:14px"
            />
          </div>
          <div style="flex:1">
            <label style="display:block;margin-bottom:4px;font-weight:600">To</label>
            <input
              id="seq-to"
              type="number"
              value="5"
              style="width:100%;box-sizing:border-box;padding:6px 8px;border:1px solid #ccc;border-radius:4px;font-size:14px"
            />
          </div>
        </div>

        <div style="margin-bottom:8px">
          <label style="display:block;margin-bottom:4px;font-weight:600">
            Preview
          </label>
          <input
            id="seq-preview"
            type="text"
            disabled
            style="
              width:100%;box-sizing:border-box;padding:6px 8px;
              border:1px solid #ddd;border-radius:4px;font-size:14px;
              background:#f3f3f3;color:#888;cursor:not-allowed
            "
          />
          <label style="display:block;margin-bottom:4px;font-weight:600">To</label>
          <input
            id="seq-preview-end"
            type="text"
            disabled
            style="
              width:100%;box-sizing:border-box;padding:6px 8px;
              border:1px solid #ddd;border-radius:4px;font-size:14px;
              background:#f3f3f3;color:#888;cursor:not-allowed
            "
          />
        </div>

        <div
          id="seq-error"
          style="color:#e53935;font-size:.85em;min-height:18px;margin-top:2px"
        ></div>

      </div>

      <div class="custom-alert-buttons">
        <button class="custom-alert-btn cancel" id="seq-cancel">Cancel</button>
        <button class="custom-alert-btn confirm" id="seq-create">Create</button>
      </div>
    `;

        overlay.appendChild(box);
        document.body.appendChild(overlay);

        const nameInput = box.querySelector("#seq-task-name");
        const fromInput = box.querySelector("#seq-from");
        const toInput = box.querySelector("#seq-to");
        const preview = box.querySelector("#seq-preview");
        const previewEnd = box.querySelector("#seq-preview-end");
        const errorEl = box.querySelector("#seq-error");
        const cancelBtn = box.querySelector("#seq-cancel");
        const createBtn = box.querySelector("#seq-create");
        const radios = box.querySelectorAll("input[name='seq-position']");

        function updatePreview() {
          const name = nameInput.value.trim();
          const from = parseInt(fromInput.value, 10);
          const to = parseInt(toInput.value, 10);
          const isSuffix = box.querySelector("#seq-suffix").checked;

          if (!name || isNaN(from)) {
            preview.value = "";
            previewEnd.value = "";
            return;
          }
          preview.value = isSuffix ? `${name}${from}` : `${from}${name}`;

          if (!isNaN(to)) {
            previewEnd.value = isSuffix ? `${name}${to}` : `${to}${name}`;
          } else {
            previewEnd.value = "";
          }
        }

        [nameInput, fromInput, toInput].forEach((el) =>
          el.addEventListener("input", updatePreview),
        );
        radios.forEach((r) => r.addEventListener("change", updatePreview));

        updatePreview();

        function validate() {
          const name = nameInput.value.trim();
          const from = parseInt(fromInput.value, 10);
          const to = parseInt(toInput.value, 10);

          if (!name) {
            errorEl.textContent = "‚ö† Task Name must not be empty.";
            return false;
          }
          if (isNaN(from) || isNaN(to)) {
            errorEl.textContent = "‚ö† From and To must be valid integers.";
            return false;
          }
          if (from > to) {
            errorEl.textContent = "‚ö† From must be ‚â§ To.";
            return false;
          }
          errorEl.textContent = "";
          return true;
        }

        function closeDialog() {
          box.style.animation = "popOut 0.3s forwards";
          setTimeout(() => document.body.removeChild(overlay), 300);
        }

        cancelBtn.addEventListener("click", closeDialog);

        overlay.addEventListener("keydown", (e) => {
          if (e.key === "Escape") closeDialog();
        });

        createBtn.addEventListener("click", async () => {
          if (!validate()) return;

          const name = nameInput.value.trim();
          const from = parseInt(fromInput.value, 10);
          const to = parseInt(toInput.value, 10);
          const isSuffix = box.querySelector("#seq-suffix").checked;

          createBtn.disabled = true;
          cancelBtn.disabled = true;
          createBtn.textContent = "Creating‚Ä¶";
          errorEl.style.color = "#1976d2";
          errorEl.textContent = `Creating ${to - from + 1} task(s)‚Ä¶`;

          try {
            for (let i = from; i <= to; i++) {
              const title = isSuffix ? `${name}${i}` : `${i}${name}`;
              await ApiService.createTask(title);
            }

            await app.loadTodos();
            closeDialog();
          } catch (err) {
            createBtn.disabled = false;
            cancelBtn.disabled = false;
            createBtn.textContent = "Create";
            errorEl.style.color = "#e53935";
            errorEl.textContent = "‚ö† Error: " + err.message;
          }
        });

        nameInput.focus();
      }
    </script>
  </body>
</html>
